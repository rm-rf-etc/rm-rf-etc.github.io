<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Rob Christian by rm-rf-etc</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-light.css">
    <meta name="viewport" content="width=device-width">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Rob Christian</h1>
        <p>I&#39;m a programmer. Here&#39;s some stuff I&#39;ve made.</p>


        <p class="view"><a href="https://github.com/rm-rf-etc">View My GitHub Profile</a></p>

      </header>
      <section>
<h2>
<a id="concise-experimental-fe-framework" class="anchor" href="#concise-experimental-fe-framework" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Concise: Experimental FE Framework</h2>

<p>Prior to learning React, I started this experiment to test out some ideas I had around data binding and view rendering. I first created connected.js, a library that creates bindable JS Objects and Arrays, and triggers updates using events. This seemed successful, and next I wanted to use it in view rendering. I contemplated using Handlebars, but I had become frustrated at work after an external team had mangled our Handlebars templates and created unnecessary cleanup work. I came up with the idea of representing markup using JS objects. This approach means valid markup is always enforced.</p>

<div class="highlight highlight-source-js">
<pre>{
    body<span class="pl-k">:</span> {
        h1<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Page Title<span class="pl-pds">'</span></span>,
        div<span class="pl-k">:</span> {
            p1<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>Lorem ipsum<span class="pl-pds">'</span></span>,
            p2<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>delor sit amet<span class="pl-pds">'</span></span>
        },
        <span class="pl-en">button</span><span class="pl-k">:</span> <span class="pl-k">function</span>(self) {
            self.<span class="pl-en">onClick</span>(<span class="pl-k">function</span>() {
                <span class="pl-en">alert</span>(<span class="pl-s"><span class="pl-pds">'</span>Click event!<span class="pl-pds">'</span></span>)
            })
        }
    }
}</pre>
</div>

<p>The result was concise.js.</p>
<p>When minified, it's ~17 KB. After gzip, <em>it's only ~6.8 KB.</em></p>
<p>Although it's only experimental, with such small size, it may show promise as a lightweight React alternative.</p>

<p>Below shows a working To-Do app using concise.js.</p>

<div id="concise-app"></div>

<h2>
<a id="encore-a-node-mvc" class="anchor" href="#encore-a-node-mvc" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Encore: A Node MVC</h2>

<a href="//github.com/rm-rf-etc/encore">github.com/rm-rf-etc/encore</a>

<p>Back when I was getting interested in node.js, I was frustrated by a seeming lack of structure in express projects. I preferred MVC at the time, so I started toying with ways to make a node app structured more like my favorite MVC's.</p>

<p>First I made a router (I didn't care for the routers I found on github). Express will test all routes in order, which isn't optimal. Runway.js instead tests each segment in order, and supports arbitrary RegEx patterns. Internally, runway uses standard tools from lodash to build a tree by creating each branch and then merging it into the tree.</p>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/concise.min.js"></script>
    <script src="javascripts/main.js"></script>
  </body>
</html>
